name: Common CD code

on:
  workflow_call:
    inputs:
      upload_url:
        required: true
        type: string
      version:
        required: true
        type: string
      os:
        required: true
        type: string
      rid:
        required: true
        type: string
      is_windows:
        required: true
        type: boolean
      channel:
        required: true
        type: string
      targetPlatform:
        required: true
        type: string
    secrets:
      Base64_Encoded_Pfx:
        required: false
      Pfx_Key:
        required: false

jobs:
  build-artifacts:
    name: Build ${{ inputs.os }} - ${{ inputs.rid }}
    runs-on: ${{ inputs.os }}
    env:
      # Common Paths
      Solution_Path: Mil.Paperwork.WriteOff.sln
      UI_Project_Path: Mil.Paperwork.UI/Mil.Paperwork.UI.csproj
      # Windows Specifics
      Wap_Project_Directory: Mil.Paperwork.Package
      App_Packages_Archive: AppPackages.zip
      App_Packages_Directory: AppPackages
      SigningCertificate: certificate.pfx
      MsbuildCmd: msbuild
      Configuration: ${{ inputs.channel }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x

    # --- WINDOWS SPECIFIC SETUP ---
    - name: Setup MSBuild (Windows Only)
      if: inputs.is_windows == true
      uses: microsoft/setup-msbuild@v2

    - name: Decode Pfx (Windows Only)
      if: inputs.is_windows == true
      run: |
        $pfx_cert_byte = [System.Convert]::FromBase64String("${{ secrets.Base64_Encoded_Pfx }}")
        $currentDirectory = Get-Location
        $certificatePath = Join-Path -Path $currentDirectory -ChildPath $env:Wap_Project_Directory -AdditionalChildPath $env:SigningCertificate
        [IO.File]::WriteAllBytes("$certificatePath", $pfx_cert_byte)
      shell: pwsh

    - name: Update Manifest Version (Windows Only)
      if: inputs.is_windows == true
      run: |
        [xml]$manifest = get-content ".\$env:Wap_Project_Directory\Package.appxmanifest"
        $manifest.Package.Identity.Version = "${{ inputs.version }}.0"
        $manifest.save(".\$env:Wap_Project_Directory\Package.appxmanifest")
      shell: pwsh

    # --- BUILD & PUBLISH (COMMON) ---
    - name: Restore dependencies
      run: dotnet restore ${{ env.Solution_Path }} -r ${{ inputs.rid }}

    - name: Publish Self-Contained App
      run: |
        dotnet publish ${{ env.UI_Project_Path }} -c Release -r ${{ inputs.rid }} --self-contained true -p:PublishSingleFile=true -o publish/

    # --- PACKAGING ---

    # Create macOS app bundle (needed when using PublishSingleFile=true)
    - name: Create macOS App Bundle
      if: inputs.is_windows == false
      run: |
        APP_NAME="Mil.Paperwork.UI"
        APP_BUNDLE_NAME="${APP_NAME}.app"
        BUNDLE_DIR="publish/${APP_BUNDLE_NAME}"
        CONTENTS_DIR="${BUNDLE_DIR}/Contents"
        MACOS_DIR="${CONTENTS_DIR}/MacOS"
        RESOURCES_DIR="${CONTENTS_DIR}/Resources"
        
        echo "Creating macOS app bundle structure..."
        
        # Create app bundle directory structure
        mkdir -p "${MACOS_DIR}"
        mkdir -p "${RESOURCES_DIR}"
        
        # Move the executable to MacOS directory
        if [ -f "publish/${APP_NAME}" ]; then
          mv "publish/${APP_NAME}" "${MACOS_DIR}/${APP_NAME}"
          chmod +x "${MACOS_DIR}/${APP_NAME}"
          echo "✓ Moved executable to MacOS directory"
        else
          echo "✗ Error: Executable publish/${APP_NAME} not found"
          exit 1
        fi
        
        # Copy icon to Resources if it exists
        if [ -f "publish/Assets/temp-logo.icns" ]; then
          cp "publish/Assets/temp-logo.icns" "${RESOURCES_DIR}/temp-logo.icns"
          echo "✓ Copied icon to Resources"
        elif [ -f "Mil.Paperwork.UI/Assets/temp-logo.icns" ]; then
          cp "Mil.Paperwork.UI/Assets/temp-logo.icns" "${RESOURCES_DIR}/temp-logo.icns"
          echo "✓ Copied icon to Resources"
        fi
        
        # Copy Data and Templates to MacOS directory (needed for AppDomain.CurrentDomain.BaseDirectory)
        if [ -d "publish/Data" ]; then
          cp -r "publish/Data" "${MACOS_DIR}/"
          echo "✓ Copied Data directory to MacOS"
        fi
        
        if [ -d "publish/Templates" ]; then
          cp -r "publish/Templates" "${MACOS_DIR}/"
          echo "✓ Copied Templates directory to MacOS"
        fi
        
        # Copy native libraries to MacOS directory
        for lib in publish/*.dylib; do
          if [ -f "$lib" ]; then
            cp "$lib" "${MACOS_DIR}/"
            echo "✓ Copied $(basename "$lib")"
          fi
        done
        
        # Create Info.plist
        cat > "${CONTENTS_DIR}/Info.plist" << 'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleExecutable</key>
            <string>Mil.Paperwork.UI</string>
            <key>CFBundleIdentifier</key>
            <string>com.vvnikolaiev.mil.paperwork</string>
            <key>CFBundleName</key>
            <string>Mil.Paperwork.UI</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleVersion</key>
            <string>1.0</string>
            <key>CFBundleShortVersionString</key>
            <string>1.0</string>
            <key>CFBundleIconFile</key>
            <string>temp-logo</string>
            <key>LSMinimumSystemVersion</key>
            <string>10.15</string>
        </dict>
        </plist>
        EOF
        echo "✓ Created Info.plist"
        
        # Create PkgInfo
        echo "APPL????" > "${CONTENTS_DIR}/PkgInfo"
        echo "✓ Created PkgInfo"
        
        echo "✓ App bundle created: ${BUNDLE_DIR}"

    # ZIP for macOS (Crucial for preserving permissions)
    - name: Zip macOS Artifact
      if: inputs.is_windows == false
      run: |
        cd publish
        # Find .app bundles
        APP_BUNDLES=$(find . -maxdepth 1 -type d -name "*.app" 2>/dev/null)
        if [ -n "$APP_BUNDLES" ]; then
          APP_NAME=$(echo "$APP_BUNDLES" | head -n1 | sed 's|^\./||')
          zip -r "../MacOS-${{ inputs.rid }}.zip" "$APP_NAME"
          echo "✓ Created MacOS-${{ inputs.rid }}.zip with $APP_NAME"
        else
          echo "✗ Error: No .app bundle found in publish directory"
          ls -la
          exit 1
        fi

    # ZIP for Windows (Portable)
    - name: Zip Windows Artifact
      if: inputs.is_windows == true
      run: |
        Compress-Archive -Path publish/* -DestinationPath Windows-${{ inputs.rid }}.zip
      shell: pwsh

    # Build MSIX Bundle (Windows Only)
    - name: Build WAP MSIX (Windows Only)
      if: inputs.is_windows == true
      run: |
        & $env:MsbuildCmd $env:Solution_Path /p:Platform=${{ inputs.targetPlatform }} /p:Configuration=$env:Configuration /p:UapAppxPackageBuildMode=SideLoadOnly /p:AppxBundle=Never /p:PackageCertificateKeyFile=$env:SigningCertificate /p:PackageCertificatePassword=${{ secrets.Pfx_Key }}
      shell: pwsh

    - name: Create WAP Archive (Windows Only)
      if: inputs.is_windows
      run: |
        $appPackagesPath = Join-Path -Path $env:Wap_Project_Directory -ChildPath $env:App_Packages_Directory
        # Zip everything in AppPackages folder into a file named AppPackages.zip
        Compress-Archive -Path "$appPackagesPath\*" -DestinationPath "$appPackagesPath\AppPackages.zip" -Force
      shell: pwsh
    # --- UPLOADING ---

    # Upload macOS Zip
    - name: Upload macOS Asset
      if: inputs.is_windows == false
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ inputs.upload_url }}
        asset_path: ./MacOS-${{ inputs.rid }}.zip
        asset_name: UA.Mil.Paperwork-${{ inputs.version }}-macOS-${{ inputs.rid }}.zip
        asset_content_type: application/zip

    # Upload Windows Portable Zip
    - name: Upload Windows Portable Asset
      if: inputs.is_windows == true
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ inputs.upload_url }}
        asset_path: ./Windows-${{ inputs.rid }}.zip
        asset_name: UA.Mil.Paperwork-${{ inputs.version }}-Portable-Win-${{ inputs.rid }}.zip
        asset_content_type: application/zip

    # Upload Windows MSIX (from WAP)
    # Note: You might need to adjust the path logic here slightly depending on how WAP outputs the file exactly
    - name: Zip and Upload MSIX
      if: inputs.is_windows == true
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ inputs.upload_url }}  # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps
        asset_path: ${{ env.Wap_Project_Directory }}\${{ env.App_Packages_Directory }}\${{ env.App_Packages_Archive }}
        asset_name: UA.Mil.Paperwork-${{ inputs.version }}-MSIX-${{ inputs.targetPlatform }}.zip
        asset_content_type: application/zip
