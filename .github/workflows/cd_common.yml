name: Common CD code

on:
  workflow_call:
    inputs:
      upload_url:
        required: true
        type: string
      version:
        required: true
        type: string
      os:
        required: true
        type: string
      rid:
        required: true
        type: string
      is_windows:
        required: true
        type: boolean
      channel:
        required: true
        type: string
      targetPlatform:
        required: true
        type: string
    secrets:
      Base64_Encoded_Pfx:
        required: false
      Pfx_Key:
        required: false

jobs:
  build-artifacts:
    name: Build ${{ inputs.os }} - ${{ inputs.rid }}
    runs-on: ${{ inputs.os }}
    env:
      # Common Paths
      Solution_Path: Mil.Paperwork.WriteOff.sln
      UI_Project_Path: Mil.Paperwork.UI/Mil.Paperwork.UI.csproj
      # Windows Specifics
      Wap_Project_Directory: Mil.Paperwork.Package
      App_Packages_Archive: AppPackages.zip
      App_Packages_Directory: AppPackages
      SigningCertificate: certificate.pfx
      MsbuildCmd: msbuild
      Configuration: ${{ inputs.channel }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x

    # --- WINDOWS SPECIFIC SETUP ---
    - name: Setup MSBuild (Windows Only)
      if: inputs.is_windows == true
      uses: microsoft/setup-msbuild@v2

    - name: Decode Pfx (Windows Only)
      if: inputs.is_windows == true
      run: |
        $pfx_cert_byte = [System.Convert]::FromBase64String("${{ secrets.Base64_Encoded_Pfx }}")
        $currentDirectory = Get-Location
        $certificatePath = Join-Path -Path $currentDirectory -ChildPath $env:Wap_Project_Directory -AdditionalChildPath $env:SigningCertificate
        [IO.File]::WriteAllBytes("$certificatePath", $pfx_cert_byte)
      shell: pwsh

    - name: Update Manifest Version (Windows Only)
      if: inputs.is_windows == true
      run: |
        [xml]$manifest = get-content ".\$env:Wap_Project_Directory\Package.appxmanifest"
        $manifest.Package.Identity.Version = "${{ inputs.version }}.0"
        $manifest.save(".\$env:Wap_Project_Directory\Package.appxmanifest")
      shell: pwsh

    # --- BUILD & PUBLISH (COMMON) ---
    - name: Restore dependencies
      run: dotnet restore ${{ env.Solution_Path }} -r ${{ inputs.rid }}

    - name: Publish Self-Contained App
      run: |
        dotnet publish ${{ env.UI_Project_Path }} -c Release -r ${{ inputs.rid }} --self-contained true -p:PublishSingleFile=true -o publish/

    # --- PACKAGING ---

    # ZIP for macOS (Crucial for preserving permissions)
    - name: Zip macOS Artifact
      if: inputs.is_windows == false
      run: |
        cd publish
        # Avalonia on Mac usually outputs 'AppName.app'
        zip -r ../MacOS-${{ inputs.rid }}.zip *.app

    # ZIP for Windows (Portable)
    - name: Zip Windows Artifact
      if: inputs.is_windows == true
      run: |
        Compress-Archive -Path publish/* -DestinationPath Windows-${{ inputs.rid }}.zip
      shell: pwsh

    # Build MSIX Bundle (Windows Only)
    - name: Build WAP MSIX (Windows Only)
      if: inputs.is_windows == true
      run: |
        & $env:MsbuildCmd $env:Solution_Path /p:Platform=${{ inputs.targetPlatform }} /p:Configuration=$env:Configuration /p:UapAppxPackageBuildMode=SideLoadOnly /p:AppxBundle=Never /p:PackageCertificateKeyFile=$env:SigningCertificate /p:PackageCertificatePassword=${{ secrets.Pfx_Key }}
      shell: pwsh

    # --- UPLOADING ---

    # Upload macOS Zip
    - name: Upload macOS Asset
      if: inputs.is_windows == false
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ inputs.upload_url }}
        asset_path: ./MacOS-${{ inputs.rid }}.zip
        asset_name: UA.Mil.Paperwork-${{ inputs.version }}-macOS-${{ inputs.rid }}.zip
        asset_content_type: application/zip

    # Upload Windows Portable Zip
    - name: Upload Windows Portable Asset
      if: inputs.is_windows == true
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ inputs.upload_url }}
        asset_path: ./Windows-${{ inputs.rid }}.zip
        asset_name: UA.Mil.Paperwork-${{ inputs.version }}-Portable-Win-${{ inputs.rid }}.zip
        asset_content_type: application/zip

    # Upload Windows MSIX (from WAP)
    # Note: You might need to adjust the path logic here slightly depending on how WAP outputs the file exactly
    - name: Zip and Upload MSIX
      if: inputs.is_windows == true
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ inputs.upload_url }}  # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps
        asset_path: ${{ env.Wap_Project_Directory }}\${{ env.App_Packages_Directory }}\${{ env.App_Packages_Archive }}
        asset_name: UA.Mil.Paperwork-${{ inputs.version }}-MSIX-${{ inputs.targetPlatform }}.zip
        asset_content_type: application/zip
